import os
from PIL import Image
from Bin_Class import BinaryClassifier
from Mal_Class import MalwareClassifier

class MalwarePipeline:
    def __init__(self, binary_cnn_model_path="bin_cnn_model_real.pth", binary_xgb_model_path="bin_xgb_model_real.json",
                 multi_cnn_model_path="feature_extractor_test.pth", multi_xgb_model_path="feature_extractor_test.json",
                 dataset_path='/home/arnavw/Code/ml/GAJSHIELD_KJSCE/model/data/image_data/malware_dataset/train',
                 device="cuda"):
        """
        Initialize the MalwarePipeline with paths to the binary and multiclass models.
        """
        # Initialize Binary Classifier
        self.binary_classifier = BinaryClassifier(
            cnn_model_path=binary_cnn_model_path,
            xgb_model_path=binary_xgb_model_path,
            device=device
        )
        
        # Initialize Multiclass Malware Classifier
        self.multi_classifier = MalwareClassifier(
            cnn_model_path=multi_cnn_model_path,
            xgb_model_path=multi_xgb_model_path,
            dataset_path=dataset_path,
            device=device
        )

    def process_image(self, image_path):
        """
        Process a single image through the pipeline.
        """
        print(f"Processing image: {image_path}")
        # Step 1: Classify image as benign or malware using BinaryClassifier
        is_benign = self.binary_classifier.classify_image(image_path)
        is_benign_proba = self.binary_classifier.predict_probabilities(image_path)

        if is_benign:
            print(f"Image {image_path} is classified as BENIGN. With probability: {is_benign_proba[0]:.2f}%")
            return "BENIGN", is_benign_proba[0] # Return benign classification with full confidence
        
        # Step 2: If malware, classify using MalwareClassifier
        print(f"Image {image_path} is classified as MALWARE. Proceeding to multiclass classification...")
        predicted_class, confidence = self.multi_classifier.predict_class_and_confidence(image_path)
        # if confidence < 0.45:
        #     # print(f"Image {image_path} is classified as BENIGN.")
        #     return "BENIGN", 1.0
        
        # print(f"Predicted Class: {predicted_class}, Confidence: {confidence:.2f}%")
        return predicted_class, confidence

    def process_batch(self, image_paths):
        """
        Process a batch of images through the pipeline.
        """
        results = []
        for image_path in image_paths:
            result = self.process_image(image_path)
            results.append((image_path, result))
        return results
    

if __name__ == "__main__":
    # Paths to the trained models and dataset
    binary_cnn_model_path = "bin_cnn_model_real.pth"
    binary_xgb_model_path = "bin_xgb_model_real.json"
    multi_cnn_model_path = "feature_extractor_test.pth"
    multi_xgb_model_path = "feature_extractor_test.json"
    dataset_path = '/home/arnavw/Code/ml/GAJSHIELD_KJSCE/model/data/image_data/malware_dataset/train'

    # Initialize the pipeline
    pipeline = MalwarePipeline(
        binary_cnn_model_path=binary_cnn_model_path,
        binary_xgb_model_path=binary_xgb_model_path,
        multi_cnn_model_path=multi_cnn_model_path,
        multi_xgb_model_path=multi_xgb_model_path,
        dataset_path=dataset_path
    )

    # Example: Single image processing
    test_image_path = "exam6.png"
    predicted_class, confidence = pipeline.process_image(test_image_path)
    print(f"Final Result - Predicted Class: {predicted_class}, Confidence: {confidence:.2f}%")

    # Example: Batch processing
    # batch_image_paths = ["test_bytecode_image_1.png", "test_bytecode_image_2.png"]
    # batch_results = pipeline.process_batch(batch_image_paths)
    # for image_path, (predicted_class, confidence) in batch_results:
    #     print(f"Image: {image_path}, Predicted Class: {predicted_class}, Confidence: {confidence:.2f}%")
