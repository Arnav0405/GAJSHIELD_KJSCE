import os
import numpy as np
import torch
import torch.nn as nn
from torchvision import transforms
from PIL import Image
from xgboost import XGBClassifier

# Define the CNN architecture
class FeatureExtractorCNN(nn.Module):
    def __init__(self):
        super(FeatureExtractorCNN, self).__init__()
        self.model = nn.Sequential(
            # Block 1
            nn.Conv2d(in_channels=1, out_channels=64, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm2d(64),
            nn.GELU(),
            nn.MaxPool2d(kernel_size=2, stride=2),  # Output: (Batch, 64, 32, 32)
            
            # Block 2
            nn.Conv2d(in_channels=64, out_channels=64, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm2d(64),
            nn.GELU(),
            nn.Dropout(0.2),
            nn.MaxPool2d(kernel_size=2, stride=2),  # Output: (Batch, 64, 16, 16)
            
            # Block 3
            nn.Conv2d(in_channels=64, out_channels=32, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm2d(32),
            nn.GELU(),
            nn.Dropout(0.3),
            nn.MaxPool2d(kernel_size=2, stride=2),  # Output: (Batch, 32, 8, 8)
            
            # Flatten
            nn.Flatten(),
            
            # Fully Connected Layer
            nn.Linear(32 * 8 * 8, 256),  # Adjust based on input size
            nn.LeakyReLU(),
            nn.Dropout(0.5),
            nn.Linear(256, 128),  # Final feature vector size
            nn.ReLU()
        )
    
    def forward(self, x):
        return self.model(x)



# Function to preprocess the input image
def preprocess_image(image_path, target_size=(64, 64)):
    transform = transforms.Compose([
            transforms.Resize((64, 64)),  # Resize to fixed size
            transforms.Grayscale(num_output_channels=1),  # Convert to grayscale
            transforms.ToTensor(),  # Convert to tensor
            transforms.Normalize(mean=[0.5], std=[0.5])  # Normalize
        ])
    image = Image.open(image_path)
    return transform(image).unsqueeze(0)  # Add batch dimension

# Function to load the trained models
def load_models(cnn_model_path, xgb_model_path, dataset_path, device):
    # Load the CNN model
    cnn_model = FeatureExtractorCNN().to(device)
    cnn_model.load_state_dict(torch.load(cnn_model_path, map_location=device))
    cnn_model.eval()  # Set to evaluation mode
    
    # Load the XGBoost model
    xgb_model = XGBClassifier()
    xgb_model.load_model(xgb_model_path)
    
    from torchvision import datasets
    dataset = datasets.ImageFolder(root=dataset_path)
    class_names = dataset.classes  # List of class names

    return cnn_model, xgb_model, class_names

# Function to predict the class of a single image
def predict_single_image(image_path, cnn_model, xgb_model, class_names, device):
    # Preprocess the image
    image_tensor = preprocess_image(image_path).to(device)
    
    # Extract features using the CNN
    with torch.no_grad():
        features = cnn_model(image_tensor).cpu().numpy()
    
    # Predict probabilities using XGBoost
    probabilities = xgb_model.predict_proba(features)[0]  # Shape: (num_classes,)
    
    # Get the predicted class index and confidence
    predicted_class_index = np.argmax(probabilities)
    predicted_class_name = class_names[predicted_class_index]
    confidence = probabilities[predicted_class_index] * 100  # Convert to percentage
    
    return predicted_class_name, confidence

# Main function
if __name__ == "__main__":
    TPATH = '/home/arnavw/Code/ml/GAJSHIELD_KJSCE/model/data/image_data/malware_dataset/train'
    # Paths to the trained models
    cnn_model_path = "feature_extractor_test.pth"
    xgb_model_path = "feature_extractor_test.json"
    dataset_path = TPATH
    
    # Path to the input image
    image_path = "test_bytecode_image.png"
    
    # Device configuration (GPU or CPU)
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    
    # Load the models
    cnn_model, xgb_model, class_names = load_models(cnn_model_path, xgb_model_path, dataset_path, device)
    
    # Predict the class of the input image
    predicted_class_name, confidence = predict_single_image(image_path, cnn_model, xgb_model, class_names, device)
    print(f"Predicted Class: {predicted_class_name}, Confidence: {confidence:.2f}%")